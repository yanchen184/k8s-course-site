name: Auto Fix Issue with AI

on:
  issues:
    types: [labeled]

jobs:
  auto-fix:
    if: contains(github.event.issue.labels.*.name, 'auto-fix')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create fix script
        run: |
          cat > fix-issue.mjs << 'SCRIPT'
          import fs from 'fs';
          import path from 'path';

          const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
          const ISSUE_TITLE = process.env.ISSUE_TITLE;
          const ISSUE_BODY = process.env.ISSUE_BODY;

          // Get all source files
          function getAllFiles(dir, extensions = ['.ts', '.tsx', '.js', '.jsx', '.css', '.html', '.json', '.md']) {
            let results = [];
            try {
              const list = fs.readdirSync(dir);
              for (const file of list) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  if (!['node_modules', '.git', 'dist', 'build', '.next', '.github'].includes(file)) {
                    results = results.concat(getAllFiles(filePath, extensions));
                  }
                } else if (extensions.some(ext => file.endsWith(ext))) {
                  results.push(filePath);
                }
              }
            } catch (e) {}
            return results;
          }

          // Read file contents (limit size)
          function readFileSafe(filePath, maxSize = 8000) {
            try {
              const content = fs.readFileSync(filePath, 'utf-8');
              return content.length > maxSize ? content.slice(0, maxSize) + '\n... (truncated)' : content;
            } catch (e) {
              return '';
            }
          }

          // Call Gemini API using fetch
          async function callGemini(prompt) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

            const body = {
              contents: [{ parts: [{ text: prompt }] }],
              generationConfig: {
                temperature: 0.1,
                maxOutputTokens: 8192
              }
            };

            console.log('API URL:', url.replace(GEMINI_API_KEY, '***'));
            console.log('Request body size:', JSON.stringify(body).length, 'bytes');

            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });

            console.log('Response status:', response.status);

            if (!response.ok) {
              const errorText = await response.text();
              console.log('Error response:', errorText);
              throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            const json = await response.json();
            console.log('Response keys:', Object.keys(json));

            if (json.error) {
              throw new Error(`Gemini error: ${json.error.message}`);
            }

            const text = json.candidates?.[0]?.content?.parts?.[0]?.text || '';
            console.log('Response text length:', text.length);

            if (!text) {
              console.log('Full response:', JSON.stringify(json, null, 2));
            }

            return text;
          }

          async function main() {
            console.log('=== Auto Fix Issue with Gemini ===');
            console.log('Issue:', ISSUE_TITLE);
            console.log('API Key present:', !!GEMINI_API_KEY);
            console.log('API Key length:', GEMINI_API_KEY?.length || 0);
            console.log('');

            // Gather codebase context
            const files = getAllFiles('.');
            console.log('Found', files.length, 'source files');

            let codeContext = '';
            const filesToInclude = files.slice(0, 25);
            for (const file of filesToInclude) {
              const content = readFileSafe(file, 4000);
              if (content) {
                codeContext += `\n### File: ${file}\n\`\`\`\n${content}\n\`\`\`\n`;
              }
            }
            console.log('Code context size:', codeContext.length, 'chars');

            // Create prompt for Gemini
            const prompt = `You are a senior developer tasked with fixing a GitHub issue.

## Issue Title
${ISSUE_TITLE}

## Issue Description
${ISSUE_BODY || 'No description provided'}

## Repository Files
${codeContext}

## Your Task
Analyze the issue and provide a fix. Respond with ONLY a JSON object in this exact format:

\`\`\`json
{
  "analysis": "Brief explanation of the problem and solution",
  "files_to_modify": [
    {
      "path": "README.md",
      "new_content": "The complete new file content here"
    }
  ],
  "summary": "One-line summary of what was fixed"
}
\`\`\`

Rules:
- Provide COMPLETE file contents in new_content, not partial changes
- If modifying README.md, include the full updated README
- Output ONLY the JSON block with no additional text before or after`;

            console.log('Prompt length:', prompt.length, 'chars');
            console.log('Calling Gemini API...');

            const response = await callGemini(prompt);
            console.log('Raw response preview:', response.substring(0, 500));

            // Extract JSON from response
            let jsonStr = response;
            const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
            if (jsonMatch) {
              jsonStr = jsonMatch[1];
            } else {
              // Try to find raw JSON
              const rawMatch = response.match(/\{[\s\S]*\}/);
              if (rawMatch) {
                jsonStr = rawMatch[0];
              }
            }

            let fix;
            try {
              fix = JSON.parse(jsonStr);
            } catch (e) {
              console.log('Failed to parse JSON:', e.message);
              console.log('Attempted to parse:', jsonStr.substring(0, 1000));
              fs.writeFileSync('fix-result.json', JSON.stringify({
                success: false,
                reason: 'Failed to parse JSON response',
                rawResponse: response.substring(0, 2000)
              }));
              return;
            }

            console.log('Analysis:', fix.analysis);
            console.log('Summary:', fix.summary);

            // Apply fixes
            let filesChanged = [];

            for (const file of fix.files_to_modify || []) {
              if (file.path && file.new_content) {
                console.log(`Modifying: ${file.path}`);
                const dir = path.dirname(file.path);
                if (dir && dir !== '.') {
                  fs.mkdirSync(dir, { recursive: true });
                }
                fs.writeFileSync(file.path, file.new_content);
                filesChanged.push(file.path);
              }
            }

            fs.writeFileSync('fix-result.json', JSON.stringify({
              success: filesChanged.length > 0,
              analysis: fix.analysis,
              summary: fix.summary,
              filesChanged
            }, null, 2));

            console.log('Fix complete!', filesChanged.length, 'files changed');
          }

          main().catch(err => {
            console.error('Error:', err.message);
            console.error('Stack:', err.stack);
            fs.writeFileSync('fix-result.json', JSON.stringify({
              success: false,
              reason: err.message
            }));
            process.exit(1);
          });
          SCRIPT

      - name: Run AI fix
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: node fix-issue.mjs

      - name: Check fix result
        id: check
        run: |
          if [ -f fix-result.json ]; then
            SUCCESS=$(cat fix-result.json | jq -r '.success')
            SUMMARY=$(cat fix-result.json | jq -r '.summary // "No summary"')
            echo "success=$SUCCESS" >> $GITHUB_OUTPUT
            echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
            cat fix-result.json
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "summary=Fix script failed" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: steps.check.outputs.success == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "fix: ${{ steps.check.outputs.summary }}"
          title: "AI Fix: ${{ github.event.issue.title }}"
          body: |
            ## Auto-generated fix for #${{ github.event.issue.number }}

            **Issue:** ${{ github.event.issue.title }}

            **Summary:** ${{ steps.check.outputs.summary }}

            ---
            This PR was automatically generated by AI (Gemini 1.5 Flash).
            Please review the changes carefully before merging.

            Closes #${{ github.event.issue.number }}
          branch: auto-fix/issue-${{ github.event.issue.number }}
          delete-branch: true

      - name: Comment on issue (success)
        if: steps.check.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ¤– AI has analyzed this issue and created a fix!\n\nA Pull Request has been opened. Please review the changes.\n\n**Summary:** ${{ steps.check.outputs.summary }}`
            })

      - name: Comment on issue (failed)
        if: steps.check.outputs.success != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ¤– AI attempted to analyze this issue but encountered an error.\n\nThis may require manual intervention or more details in the issue description.`
            })
