name: Auto Fix Issue with AI

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: true
        type: number

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Determine issue number
        id: issue
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "number=${{ inputs.issue_number }}" >> $GITHUB_OUTPUT
          else
            echo "number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Check auto-fix label (skip for workflow_dispatch)
        if: github.event_name == 'issues'
        run: |
          LABELS='${{ toJson(github.event.issue.labels.*.name) }}'
          if ! echo "$LABELS" | grep -q "auto-fix"; then
            echo "Issue does not have auto-fix label, skipping"
            exit 0
          fi

      - name: Get issue details
        id: get_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_JSON=$(gh issue view ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} --json title,body)
          TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
          BODY=$(echo "$ISSUE_JSON" | jq -r '.body')
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          {
            echo 'body<<EOF'
            echo "$BODY"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create and run fix script
        id: fix
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ steps.get_issue.outputs.title }}
          ISSUE_BODY: ${{ steps.get_issue.outputs.body }}
        run: |
          cat > fix-issue.mjs << 'SCRIPT'
          import fs from 'fs';
          import path from 'path';

          const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
          const ISSUE_TITLE = process.env.ISSUE_TITLE;
          const ISSUE_BODY = process.env.ISSUE_BODY;

          function getAllFiles(dir, extensions = ['.ts', '.tsx', '.js', '.jsx', '.css', '.html', '.json', '.md']) {
            let results = [];
            try {
              const list = fs.readdirSync(dir);
              for (const file of list) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  if (!['node_modules', '.git', 'dist', 'build', '.next', '.github'].includes(file)) {
                    results = results.concat(getAllFiles(filePath, extensions));
                  }
                } else if (extensions.some(ext => file.endsWith(ext))) {
                  results.push(filePath);
                }
              }
            } catch (e) {}
            return results;
          }

          function readFileSafe(filePath, maxSize = 6000) {
            try {
              const content = fs.readFileSync(filePath, 'utf-8');
              return content.length > maxSize ? content.slice(0, maxSize) + '\n...(truncated)' : content;
            } catch (e) {
              return '';
            }
          }

          async function callGemini(prompt) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { temperature: 0.1, maxOutputTokens: 8192 }
              })
            });

            console.log('Gemini API status:', response.status);

            if (!response.ok) {
              const err = await response.text();
              throw new Error(`API error ${response.status}: ${err}`);
            }

            const json = await response.json();

            if (json.error) {
              throw new Error(`Gemini error: ${json.error.message}`);
            }

            return json.candidates?.[0]?.content?.parts?.[0]?.text || '';
          }

          async function main() {
            console.log('=== Auto Fix Issue ===');
            console.log('Issue:', ISSUE_TITLE);
            console.log('API Key exists:', !!GEMINI_API_KEY);

            const files = getAllFiles('.');
            console.log('Found', files.length, 'files');

            let codeContext = '';
            for (const file of files.slice(0, 20)) {
              const content = readFileSafe(file);
              if (content) {
                codeContext += `\n### ${file}\n\`\`\`\n${content}\n\`\`\`\n`;
              }
            }

            const prompt = `You are fixing a GitHub issue. Analyze and provide a solution.

## Issue: ${ISSUE_TITLE}

## Description
${ISSUE_BODY || 'No description'}

## Code Files
${codeContext}

## Response Format
Respond with ONLY this JSON (no other text):

\`\`\`json
{
  "analysis": "What the issue is about",
  "files_to_modify": [
    {"path": "file.md", "new_content": "complete file content"}
  ],
  "summary": "Brief fix description"
}
\`\`\`

Important: Provide COMPLETE file content, not diffs.`;

            console.log('Calling Gemini...');
            const response = await callGemini(prompt);
            console.log('Response length:', response.length);
            console.log('Response preview:', response.substring(0, 300));

            const match = response.match(/```json\s*([\s\S]*?)\s*```/) || response.match(/(\{[\s\S]*\})/);
            if (!match) {
              throw new Error('No JSON found in response');
            }

            const fix = JSON.parse(match[1]);
            console.log('Analysis:', fix.analysis);

            let changed = [];
            for (const f of fix.files_to_modify || []) {
              if (f.path && f.new_content) {
                const dir = path.dirname(f.path);
                if (dir !== '.') fs.mkdirSync(dir, { recursive: true });
                fs.writeFileSync(f.path, f.new_content);
                changed.push(f.path);
                console.log('Modified:', f.path);
              }
            }

            fs.writeFileSync('fix-result.json', JSON.stringify({
              success: changed.length > 0,
              summary: fix.summary,
              filesChanged: changed
            }));
          }

          main().catch(err => {
            console.error('Error:', err.message);
            fs.writeFileSync('fix-result.json', JSON.stringify({ success: false, reason: err.message }));
            process.exit(1);
          });
          SCRIPT

          node fix-issue.mjs

      - name: Check result
        id: check
        run: |
          cat fix-result.json
          SUCCESS=$(jq -r '.success' fix-result.json)
          SUMMARY=$(jq -r '.summary // "No changes"' fix-result.json)
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.check.outputs.success == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "fix: ${{ steps.check.outputs.summary }}"
          title: "AI Fix: ${{ steps.get_issue.outputs.title }}"
          body: |
            ## Auto-fix for #${{ steps.issue.outputs.number }}

            **Issue:** ${{ steps.get_issue.outputs.title }}
            **Summary:** ${{ steps.check.outputs.summary }}

            ---
            Generated by AI (Gemini 1.5 Flash). Please review carefully.

            Closes #${{ steps.issue.outputs.number }}
          branch: auto-fix/issue-${{ steps.issue.outputs.number }}
          delete-branch: true

      - name: Comment on success
        if: steps.check.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} \
            --body "ðŸ¤– AI has created a fix! A PR has been opened. Summary: ${{ steps.check.outputs.summary }}"

      - name: Comment on failure
        if: steps.check.outputs.success != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} \
            --body "ðŸ¤– AI could not generate a fix for this issue. Manual intervention may be required."
