name: AI Auto Fix Issue

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: true
        type: number
  repository_dispatch:
    types: [auto-fix]

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Determine issue number
        id: issue
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "number=${{ inputs.issue_number }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "number=${{ github.event.client_payload.issue_number }}" >> $GITHUB_OUTPUT
          else
            echo "number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Check auto-fix label (skip for workflow_dispatch)
        if: github.event_name == 'issues'
        run: |
          LABELS='${{ toJson(github.event.issue.labels.*.name) }}'
          if ! echo "$LABELS" | grep -q "auto-fix"; then
            echo "Issue does not have auto-fix label, skipping"
            exit 0
          fi

      - name: Get issue details
        id: get_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_JSON=$(gh issue view ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} --json title,body)
          TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
          BODY=$(echo "$ISSUE_JSON" | jq -r '.body')
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          {
            echo 'body<<EOF'
            echo "$BODY"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create fix script
        run: |
          cat > fix-issue.mjs << 'ENDOFSCRIPT'
          import fs from 'fs';
          import path from 'path';

          const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
          const ISSUE_TITLE = process.env.ISSUE_TITLE || 'Unknown Issue';
          const ISSUE_BODY = process.env.ISSUE_BODY || 'No description provided';

          function getAllFiles(dir, extensions) {
            extensions = extensions || ['.ts', '.tsx', '.js', '.jsx', '.css', '.html', '.json', '.md'];
            let results = [];
            try {
              const list = fs.readdirSync(dir);
              for (const file of list) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  if (!['node_modules', '.git', 'dist', 'build', '.next', '.github'].includes(file)) {
                    results = results.concat(getAllFiles(filePath, extensions));
                  }
                } else if (extensions.some(function(ext) { return file.endsWith(ext); })) {
                  results.push(filePath);
                }
              }
            } catch (e) {}
            return results;
          }

          function readFileSafe(filePath, maxSize) {
            maxSize = maxSize || 6000;
            try {
              const content = fs.readFileSync(filePath, 'utf-8');
              return content.length > maxSize ? content.slice(0, maxSize) + '\n...(truncated)' : content;
            } catch (e) {
              return '';
            }
          }

          function sleep(ms) {
            return new Promise(function(resolve) { setTimeout(resolve, ms); });
          }

          async function callOpenAI(prompt, maxRetries) {
            maxRetries = maxRetries || 3;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
              console.log('Attempt ' + attempt + '/' + maxRetries + '...');

              try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + OPENAI_API_KEY
                  },
                  body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [
                      { role: 'system', content: 'You are a helpful assistant that fixes GitHub issues. Always respond with valid JSON only.' },
                      { role: 'user', content: prompt }
                    ],
                    temperature: 0.1,
                    max_tokens: 16384
                  })
                });

                console.log('API status:', response.status);

                if (response.status === 429) {
                  console.log('Rate limited. Waiting 30 seconds...');
                  if (attempt < maxRetries) {
                    await sleep(30000);
                    continue;
                  }
                  throw new Error('Rate limited after all retries');
                }

                if (!response.ok) {
                  const err = await response.text();
                  console.log('Error:', err);
                  if (attempt < maxRetries) {
                    await sleep(5000);
                    continue;
                  }
                  throw new Error('API error: ' + err);
                }

                const json = await response.json();
                if (json.error) {
                  console.log('API error:', json.error.message);
                  throw new Error(json.error.message);
                }

                const text = json.choices && json.choices[0] && json.choices[0].message && json.choices[0].message.content;
                if (text) {
                  console.log('Success with OpenAI GPT-4o');
                  return text;
                }
              } catch (e) {
                console.log('Error: ' + e.message);
                if (attempt === maxRetries) throw e;
              }
            }
            throw new Error('All attempts failed');
          }

          async function main() {
            console.log('=== Auto Fix Issue ===');
            console.log('Issue:', ISSUE_TITLE);
            console.log('API Key exists:', !!OPENAI_API_KEY);

            const files = getAllFiles('.');
            console.log('Found', files.length, 'files');

            let codeContext = '';
            const filesToProcess = files.slice(0, 20);
            for (const file of filesToProcess) {
              const content = readFileSafe(file);
              if (content) {
                codeContext += '\n### ' + file + '\n```\n' + content + '\n```\n';
              }
            }

            const prompt = 'Fix this GitHub issue by modifying files.\n\n' +
              'Issue: ' + ISSUE_TITLE + '\n' + ISSUE_BODY + '\n\n' +
              'Files:\n' + codeContext + '\n\n' +
              'Reply with ONLY valid JSON (no markdown):\n' +
              '{"path":"file.md","content":"full file content","summary":"what you fixed"}\n\n' +
              'Rules:\n' +
              '- One file only\n' +
              '- Full content, no diffs\n' +
              '- No markdown code blocks';

            console.log('Calling OpenAI...');
            const response = await callOpenAI(prompt);
            console.log('Response length:', response.length);
            console.log('Response preview:', response.substring(0, 300));

            var jsonStr = response.trim();
            if (jsonStr.startsWith('```')) {
              var jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
              if (jsonMatch) jsonStr = jsonMatch[1];
            }

            console.log('Parsing JSON...');
            var fix = JSON.parse(jsonStr);
            console.log('Summary:', fix.summary);

            var changed = [];
            if (fix.path && fix.content) {
              var dir = path.dirname(fix.path);
              if (dir !== '.') fs.mkdirSync(dir, { recursive: true });
              fs.writeFileSync(fix.path, fix.content);
              changed.push(fix.path);
              console.log('Modified:', fix.path);
            }

            fs.writeFileSync('fix-result.json', JSON.stringify({
              success: changed.length > 0,
              summary: fix.summary,
              filesChanged: changed
            }));
          }

          main().catch(function(err) {
            console.error('Error:', err.message);
            fs.writeFileSync('fix-result.json', JSON.stringify({ success: false, reason: err.message }));
            process.exit(1);
          });
          ENDOFSCRIPT

      - name: Run fix script
        id: fix
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_TITLE: ${{ steps.get_issue.outputs.title }}
          ISSUE_BODY: ${{ steps.get_issue.outputs.body }}
        run: node fix-issue.mjs

      - name: Check result
        id: check
        run: |
          cat fix-result.json
          SUCCESS=$(jq -r '.success' fix-result.json)
          SUMMARY=$(jq -r '.summary // "No changes"' fix-result.json)
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.check.outputs.success == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          commit-message: "fix: ${{ steps.check.outputs.summary }}"
          title: "AI Fix: ${{ steps.get_issue.outputs.title }}"
          body: |
            ## Auto-fix for #${{ steps.issue.outputs.number }}

            **Issue:** ${{ steps.get_issue.outputs.title }}
            **Summary:** ${{ steps.check.outputs.summary }}

            ---
            Generated by OpenAI GPT-4o

            Closes #${{ steps.issue.outputs.number }}
          branch: auto-fix/issue-${{ steps.issue.outputs.number }}
          delete-branch: true

      - name: Auto merge PR
        if: steps.check.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          sleep 5
          PR_NUMBER=$(gh pr list --repo ${{ github.repository }} --head auto-fix/issue-${{ steps.issue.outputs.number }} --json number -q '.[0].number')
          if [ -n "$PR_NUMBER" ]; then
            gh pr merge $PR_NUMBER --repo ${{ github.repository }} --squash --delete-branch || echo "Auto-merge failed, PR needs manual review"
          fi

      - name: Comment on success
        if: steps.check.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} \
            --body "AI has created and merged a fix! Summary: ${{ steps.check.outputs.summary }}"

      - name: Comment on failure
        if: steps.check.outputs.success != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} \
            --body "AI could not generate a fix for this issue. Manual intervention may be required."
