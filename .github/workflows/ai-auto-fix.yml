name: AI Auto Fix Issue

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: true
        type: number
  repository_dispatch:
    types: [auto-fix]

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Determine issue number
        id: issue
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "number=${{ inputs.issue_number }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "number=${{ github.event.client_payload.issue_number }}" >> $GITHUB_OUTPUT
          else
            echo "number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Check auto-fix label (skip for workflow_dispatch)
        if: github.event_name == 'issues'
        run: |
          LABELS='${{ toJson(github.event.issue.labels.*.name) }}'
          if ! echo "$LABELS" | grep -q "auto-fix"; then
            echo "Issue does not have auto-fix label, skipping"
            exit 0
          fi

      - name: Get issue details
        id: get_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_JSON=$(gh issue view ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} --json title,body)
          TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
          BODY=$(echo "$ISSUE_JSON" | jq -r '.body')
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          {
            echo 'body<<EOF'
            echo "$BODY"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create fix script
        run: |
          cat > fix-issue.mjs << 'ENDOFSCRIPT'
          import fs from 'fs';
          import path from 'path';

          const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
          const ISSUE_TITLE = process.env.ISSUE_TITLE || 'Unknown Issue';
          const ISSUE_BODY = process.env.ISSUE_BODY || 'No description provided';

          function getAllFiles(dir, extensions) {
            extensions = extensions || ['.ts', '.tsx', '.js', '.jsx', '.css', '.html', '.json', '.md'];
            let results = [];
            try {
              const list = fs.readdirSync(dir);
              for (const file of list) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  if (!['node_modules', '.git', 'dist', 'build', '.next', '.github'].includes(file)) {
                    results = results.concat(getAllFiles(filePath, extensions));
                  }
                } else if (extensions.some(function(ext) { return file.endsWith(ext); })) {
                  results.push(filePath);
                }
              }
            } catch (e) {}
            return results;
          }

          function readFileSafe(filePath, maxSize) {
            maxSize = maxSize || 6000;
            try {
              const content = fs.readFileSync(filePath, 'utf-8');
              return content.length > maxSize ? content.slice(0, maxSize) + '\n...(truncated)' : content;
            } catch (e) {
              return '';
            }
          }

          function sleep(ms) {
            return new Promise(function(resolve) { setTimeout(resolve, ms); });
          }

          async function callGemini(prompt, maxRetries) {
            maxRetries = maxRetries || 3;
            const models = ['gemma-3n-e4b-it', 'gemma-3-27b-it', 'gemini-2.0-flash'];

            for (const model of models) {
              console.log('Trying model: ' + model);
              const url = 'https://generativelanguage.googleapis.com/v1beta/models/' + model + ':generateContent?key=' + GEMINI_API_KEY;

              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                console.log('Attempt ' + attempt + '/' + maxRetries + '...');

                try {
                  const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      contents: [{ parts: [{ text: prompt }] }],
                      generationConfig: { temperature: 0.1, maxOutputTokens: 8192 }
                    })
                  });

                  console.log('API status:', response.status);

                  if (response.status === 429) {
                    const errorJson = await response.json();
                    const retryInfo = errorJson.error && errorJson.error.details && errorJson.error.details.find(function(d) { return d.retryDelay; });
                    const waitTime = retryInfo ? parseInt(retryInfo.retryDelay) + 5 : 60;
                    console.log('Rate limited. Waiting ' + waitTime + ' seconds...');

                    if (attempt < maxRetries) {
                      await sleep(waitTime * 1000);
                      continue;
                    }
                    console.log('Model ' + model + ' rate limited, trying next...');
                    break;
                  }

                  if (!response.ok) {
                    const err = await response.text();
                    console.log('Error with ' + model + ': ' + err);
                    break;
                  }

                  const json = await response.json();
                  if (json.error) {
                    console.log('API error: ' + json.error.message);
                    break;
                  }

                  const candidates = json.candidates || [];
                  const firstCandidate = candidates[0] || {};
                  const content = firstCandidate.content || {};
                  const parts = content.parts || [];
                  const firstPart = parts[0] || {};
                  const text = firstPart.text || '';

                  if (text) {
                    console.log('Success with model: ' + model);
                    return text;
                  }
                } catch (e) {
                  console.log('Error: ' + e.message);
                  if (attempt === maxRetries) break;
                }
              }
            }
            throw new Error('All models failed or rate limited');
          }

          async function main() {
            console.log('=== Auto Fix Issue ===');
            console.log('Issue:', ISSUE_TITLE);
            console.log('API Key exists:', !!GEMINI_API_KEY);

            const files = getAllFiles('.');
            console.log('Found', files.length, 'files');

            let codeContext = '';
            const filesToProcess = files.slice(0, 20);
            for (const file of filesToProcess) {
              const content = readFileSafe(file);
              if (content) {
                codeContext += '\n### ' + file + '\n```\n' + content + '\n```\n';
              }
            }

            const prompt = 'You are fixing a GitHub issue. Analyze and provide a solution.\n\n' +
              '## Issue: ' + ISSUE_TITLE + '\n\n' +
              '## Description\n' + ISSUE_BODY + '\n\n' +
              '## Code Files\n' + codeContext + '\n\n' +
              '## Response Format\n' +
              'Respond with ONLY this JSON (no other text):\n\n' +
              '```json\n' +
              '{\n' +
              '  "analysis": "What the issue is about",\n' +
              '  "files_to_modify": [\n' +
              '    {"path": "file.md", "new_content": "complete file content"}\n' +
              '  ],\n' +
              '  "summary": "Brief fix description"\n' +
              '}\n' +
              '```\n\n' +
              'Important: Provide COMPLETE file content, not diffs.';

            console.log('Calling Gemini...');
            const response = await callGemini(prompt);
            console.log('Response length:', response.length);
            console.log('Response preview:', response.substring(0, 300));

            const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
            const objectMatch = response.match(/(\{[\s\S]*\})/);
            const match = jsonMatch || objectMatch;

            if (!match) {
              throw new Error('No JSON found in response');
            }

            const fix = JSON.parse(match[1]);
            console.log('Analysis:', fix.analysis);

            let changed = [];
            const filesToModify = fix.files_to_modify || [];
            for (const f of filesToModify) {
              if (f.path && f.new_content) {
                const dir = path.dirname(f.path);
                if (dir !== '.') fs.mkdirSync(dir, { recursive: true });
                fs.writeFileSync(f.path, f.new_content);
                changed.push(f.path);
                console.log('Modified:', f.path);
              }
            }

            fs.writeFileSync('fix-result.json', JSON.stringify({
              success: changed.length > 0,
              summary: fix.summary,
              filesChanged: changed
            }));
          }

          main().catch(function(err) {
            console.error('Error:', err.message);
            fs.writeFileSync('fix-result.json', JSON.stringify({ success: false, reason: err.message }));
            process.exit(1);
          });
          ENDOFSCRIPT

      - name: Run fix script
        id: fix
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ steps.get_issue.outputs.title }}
          ISSUE_BODY: ${{ steps.get_issue.outputs.body }}
        run: node fix-issue.mjs

      - name: Check result
        id: check
        run: |
          cat fix-result.json
          SUCCESS=$(jq -r '.success' fix-result.json)
          SUMMARY=$(jq -r '.summary // "No changes"' fix-result.json)
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.check.outputs.success == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          commit-message: "fix: ${{ steps.check.outputs.summary }}"
          title: "AI Fix: ${{ steps.get_issue.outputs.title }}"
          body: |
            ## Auto-fix for #${{ steps.issue.outputs.number }}

            **Issue:** ${{ steps.get_issue.outputs.title }}
            **Summary:** ${{ steps.check.outputs.summary }}

            ---
            Generated by AI (Gemini). Please review carefully.

            Closes #${{ steps.issue.outputs.number }}
          branch: auto-fix/issue-${{ steps.issue.outputs.number }}
          delete-branch: true

      - name: Comment on success
        if: steps.check.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} \
            --body "AI has created a fix! A PR has been opened. Summary: ${{ steps.check.outputs.summary }}"

      - name: Comment on failure
        if: steps.check.outputs.success != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ steps.issue.outputs.number }} --repo ${{ github.repository }} \
            --body "AI could not generate a fix for this issue. Manual intervention may be required."
